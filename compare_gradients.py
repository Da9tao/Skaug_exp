"""Compare distance-map gradients produced by C++ and SciPy Sobel filters.

This utility loads a morphology distance map, reproduces the gradient using
SciPy's Sobel operator, reads the gradient components generated by the C++
`grad.cpp` tool, and visualises their agreement.
"""

from __future__ import annotations

import argparse
import pathlib
from typing import Tuple

import matplotlib.pyplot as plt
import numpy as np
from scipy import ndimage


def load_grid(path: pathlib.Path) -> np.ndarray:
    data = np.loadtxt(path)
    if data.ndim != 2:
        raise ValueError(f"Expected 2D grid in {path}, got shape {data.shape}")
    return data


def load_gradients(dist_map: pathlib.Path, grad_dir: pathlib.Path | None) -> Tuple[np.ndarray, np.ndarray]:
    base_dir = grad_dir if grad_dir is not None else dist_map.parent
    grad_x_path = base_dir / f"{dist_map.stem}_grad_x.txt"
    grad_y_path = base_dir / f"{dist_map.stem}_grad_y.txt"

    if not grad_x_path.exists() or not grad_y_path.exists():
        raise FileNotFoundError(
            f"Missing gradient files {grad_x_path} or {grad_y_path}. "
            "Run grad.cpp first."
        )

    grad_x = np.loadtxt(grad_x_path)
    grad_y = np.loadtxt(grad_y_path)
    return grad_x, grad_y


def compute_scipy_gradients(dist: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    grad_x = ndimage.sobel(dist, axis=1, mode="nearest")
    grad_y = ndimage.sobel(dist, axis=0, mode="nearest")
    grad_x /= 8.0
    grad_y /= 8.0
    return grad_x, grad_y


def rms_error(a: np.ndarray, b: np.ndarray) -> float:
    return float(np.sqrt(np.mean((a - b) ** 2)))


def plot_comparison(
    dist: np.ndarray,
    cpp_grad_x: np.ndarray,
    cpp_grad_y: np.ndarray,
    py_grad_x: np.ndarray,
    py_grad_y: np.ndarray,
    output: pathlib.Path,
) -> None:
    magnitude_cpp = np.hypot(cpp_grad_x, cpp_grad_y)
    magnitude_py = np.hypot(py_grad_x, py_grad_y)
    magnitude_diff = magnitude_cpp - magnitude_py

    fig, axes = plt.subplots(2, 3, figsize=(15, 10))

    im0 = axes[0, 0].imshow(dist, cmap="viridis")
    axes[0, 0].set_title("Distance map")
    fig.colorbar(im0, ax=axes[0, 0])

    im1 = axes[0, 1].imshow(py_grad_x, cmap="coolwarm")
    axes[0, 1].set_title("SciPy Sobel grad_x")
    fig.colorbar(im1, ax=axes[0, 1])

    im2 = axes[0, 2].imshow(cpp_grad_x, cmap="coolwarm")
    axes[0, 2].set_title("C++ Sobel grad_x")
    fig.colorbar(im2, ax=axes[0, 2])

    im3 = axes[1, 0].imshow(py_grad_y, cmap="coolwarm")
    axes[1, 0].set_title("SciPy Sobel grad_y")
    fig.colorbar(im3, ax=axes[1, 0])

    im4 = axes[1, 1].imshow(cpp_grad_y, cmap="coolwarm")
    axes[1, 1].set_title("C++ Sobel grad_y")
    fig.colorbar(im4, ax=axes[1, 1])

    im5 = axes[1, 2].imshow(magnitude_diff, cmap="seismic")
    axes[1, 2].set_title("Gradient magnitude difference")
    fig.colorbar(im5, ax=axes[1, 2])

    for ax in axes.flat:
        ax.set_xticks([])
        ax.set_yticks([])

    fig.suptitle(
        "Gradient comparison\n"
        f"RMS error grad_x: {rms_error(cpp_grad_x, py_grad_x):.3e}, "
        f"grad_y: {rms_error(cpp_grad_y, py_grad_y):.3e}"
    )
    fig.tight_layout(rect=[0, 0.03, 1, 0.95])
    fig.savefig(output, dpi=200)
    plt.close(fig)


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "dist_map",
        type=pathlib.Path,
        help="Path to the morphology distance-map text file",
    )
    parser.add_argument(
        "--grad-dir",
        type=pathlib.Path,
        default=None,
        help=(
            "Directory containing the C++ gradient files. Defaults to the "
            "distance map directory."
        ),
    )
    parser.add_argument(
        "--output",
        type=pathlib.Path,
        default=pathlib.Path("gradient_comparison.png"),
        help="Destination for the comparison figure",
    )

    args = parser.parse_args()

    dist = load_grid(args.dist_map)
    cpp_grad_x, cpp_grad_y = load_gradients(args.dist_map, args.grad_dir)
    py_grad_x, py_grad_y = compute_scipy_gradients(dist)

    if cpp_grad_x.shape != dist.shape or cpp_grad_y.shape != dist.shape:
        raise ValueError(
            "Gradient and distance map shapes do not match: "
            f"dist {dist.shape}, grad_x {cpp_grad_x.shape}, grad_y {cpp_grad_y.shape}"
        )

    plot_comparison(dist, cpp_grad_x, cpp_grad_y, py_grad_x, py_grad_y, args.output)
    print(f"Saved comparison figure to {args.output}")


if __name__ == "__main__":
    main()

